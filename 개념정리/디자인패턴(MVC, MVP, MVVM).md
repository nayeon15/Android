## 디자인 패턴

```디자인 패턴의 종류와 특징들을 알기 전에 디자인 패턴이란 무엇인지 알아야 될 필요가 있다.```

+ '소프트웨어 공학'의 개념으로 접근하는 것이 안드로이드 디자인 패턴에 대해 이해하기가 쉽다.
+ 프로그래밍을 할 때 다양한 문제 상황에 대한 **재사용 가능한 해결책**이다
  + 일반적인 문제를 해결하기 위한 최선의 방법을 **공식화 혹은 정의**하는 것이다.
+ 디자인 패턴과 패러다임이나 알고리즘과는 다른 개념이다.
  + 객체지향 패러다임이든 함수형 프로그래밍 패러다임이든 문제상황은 일관되기 때문에 패러다임과는 다른 개념이다.
  + 알고리즘도 마찬가지로 문제상황은 일관되지 때문에 알고리즘과도 다른 개념이다. **디자인 패턴은 일반화된 해결책**이라 생각하는 게 좋다.
+ Creational(창조), Structural(구조), Behavioral(행동)으로 구분한다.
  + 클래스와 인스턴스에 관한 생성, 구조화, 행동과 관련있다. 디자인 패턴은 객체지향과 매우 관련이 있다.

----------



## MVC

```모델, 뷰, 컨트롤러 접근 방식```

**사용자 인터페이스와 비즈니스 로직을 분리**하여 어플리케이션의 시각적 요소나 애플리케이션 안에서 실행되는 비즈니스 로직을 서로 영향없이 쉽게 고칠 수 있다.

![image-20210405231258696](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210405231258696.png)

### Model (비즈니스 로직)

```프로그램에서 사용되는 실제 데이터 및 데이터 조작 로직을 처리하는 부분```

1. 어떤 동작을 수행할 수 있는 코드
2. 뷰나 컨트롤러에 매여있지 않아 재사용이 가능하다.
3. 사용자가 만든 class, DB, Web의 Resource 등...

### View

```사용자에게 제공되어 보여지는 UI부분```

1. 모델로부터 값을 가져와서 사용자에게 보여준다.
2. 컨트롤러와 통신을하여 이벤트를 처리한다.

### Controller

```사용자의 입력을 받고 처리하는 부분```

1. 모델과 뷰를 이어주는 역할을 한다. Activity
2. 어떻게 상호작용을 할 것인지 결정한다.
3. 주로 Activity or Fragment로 표현된다.

### 돌아가는 순서

1. Controller로 사용자의 입력이 들어온다.
2. Controller는 Model의 데이터 업데이트 및 다른 정보를 불러온다.
3. Model은 해당 데이터를 보여줄 View를 선택해서 화면에 보여준다.

### 단점

1. 컨트롤러와 뷰가 긴밀하게 연결되어 있어 뷰를 변경하면 컨트롤러도 변경해야 된다. (뷰와 모델이 서로 의존적이다.)
2. 많은 코드들이 컨트롤러로 모이면 문제가 발생할 가능성이 높다.

----------------



## MVP

```모델, 뷰, 프리젠터 접근 방식```

컨트롤러와 달리 **프리젠터**는 종속되어 있지 않아도 모델과 뷰를 연결하여 MVC 패턴이 가지고 있던 **단점의 일부를 해결**하였다.

![image-20210405232638467](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210405232638467.png)

### Model

**MVC의 Model과 동일하다.**

### View

```MVC가 가지고 있던 연결 문제를 해결```

액티비티가 뷰 인터페이스를 구현해서 프리젠터가 코드를 만들 인터페이스를 갖도록 한다.

### Presenter

```View에서 요청한 정보를 Model로부터 가공하여 View로 전달하는 부분```

1. 본질적으로는 컨트롤러의 역할을 수행하지만 뷰에 연결되는 것이 아닌 단순 인터페이스이다. (모델과 뷰는 상호동작한다.)
2. 모든 프레젠테이션 로직은 프레젠터로 한다.

### 돌아가는 순서

1. View로 사용자의 입력이 들어온다.
2. View는 Presenter에 작업요청을 한다.
3. Presenter에서 필요한 데이터를 Model에 요청한다.
4. Model은 Presenter에 필요한 데이터를 응답한다.
5. Presenter는 View epdlxjfmf dmdekqgksek
6. View는 Presenter로부터 받은 데이터을 화면에 보여 준다.

### 단점

1. 컨트롤러와 같이 시간이 지나면 코드가 모여 거대해지고 다루기 어려워진다.
2. 뷰와 프레젠터가 강한 의존성을 가지게 된다.

-------------



## MVVM

```모델, 뷰, 뷰모델 접근 방식```

WRF나 SilverLight에서 많이 사용되는 프레임워크 패턴이다. Model과 View는 다른 프레임 워크 패턴과 유사하다. 하지만 이번에는 **Presenter 대신 ViewModel이 존재**한다.

두가지 디자인 패턴을 사용한다. **Command 패턴과 Data Binding**을 사용한다. 이 두가지 패턴으로 인해 View와 ViewModel은 **의존성이 완전히 사라지게 된다.**

MVP와 마찬가지로 **View에서 입력이** 들어오면 Command 패턴을 통해 **ViewModel에 명령**을 내리게 되고 **Data Binding으로 인해 ViewModel의 값이 변화**하면 바로 View의 정보가 바뀌어져 버리게 된다.

![image-20210405234034492](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20210405234034492.png)

### Model

**MVC의 Model과 동일하다.**

### View

1. 뷰모델에 의해 보여지는 **옵저버블 변수**와 액션에 유연하게 바인딩 Activity
2. 옵저버블(Observable): 데이터 스트림을 생성하는 객체 (따로 더 공부하여 정리할 예정)

### ViewModel

```View를 표현하기 위해 만들어진 View를 위한 Model```

1. 모델을 래핑하고 뷰에 필요한 옵저버블 데이터를 준비

2. 뷰가 모델에 이벤트를 전달 할 수 있도록 훅(hook)을 준비

3. 그러면서도 뷰에 종속되지 않음!! <interface>



